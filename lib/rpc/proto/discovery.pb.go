// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: discovery.proto

package proto

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Version describes an agent's version information
type Version struct {
	// Payload is the version information payload.
	Payload              []byte   `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{0}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Version.Unmarshal(m, b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Version.Marshal(b, m, deterministic)
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return xxx_messageInfo_Version.Size(m)
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// SystemInfo groups attributes that describe a system
type SystemInfo struct {
	// Payload is the opaque system information payload.
	Payload              []byte   `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SystemInfo) Reset()         { *m = SystemInfo{} }
func (m *SystemInfo) String() string { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()    {}
func (*SystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{1}
}
func (m *SystemInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SystemInfo.Unmarshal(m, b)
}
func (m *SystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SystemInfo.Marshal(b, m, deterministic)
}
func (m *SystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemInfo.Merge(m, src)
}
func (m *SystemInfo) XXX_Size() int {
	return xxx_messageInfo_SystemInfo.Size(m)
}
func (m *SystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SystemInfo proto.InternalMessageInfo

func (m *SystemInfo) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// RuntimeConfig decribes agent's runtime configuration
type RuntimeConfig struct {
	// Role specifies the agent's role
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	// AdvertiseAddr specifies the address the agent is listening on
	AdvertiseAddr string `protobuf:"bytes,2,opt,name=advertise_addr,json=advertiseAddr,proto3" json:"advertise_addr,omitempty"`
	// DockerDevice defines the device to use to setup devicemapper docker storage backend
	// in direct-lvm mode
	DockerDevice string `protobuf:"bytes,3,opt,name=docker_device,json=dockerDevice,proto3" json:"docker_device,omitempty"`
	// SystemDevice defines the device to use to setup telekube state directory
	SystemDevice string `protobuf:"bytes,4,opt,name=system_device,json=systemDevice,proto3" json:"system_device,omitempty"`
	// Mounts lists mount overrides
	Mounts []*Mount `protobuf:"bytes,5,rep,name=mounts,proto3" json:"mounts,omitempty"`
	// StateDir specifies the location of the telekube system state directory
	StateDir string `protobuf:"bytes,6,opt,name=state_dir,json=stateDir,proto3" json:"state_dir,omitempty"`
	// TODO: TempDir specifies the location of the temporary directory. It is part of the runtime
	// configuration as it can potentially become local to system directory - independent of OS
	TempDir string `protobuf:"bytes,7,opt,name=temp_dir,json=tempDir,proto3" json:"temp_dir,omitempty"`
	// Token authorizes the peer to join an operation.
	Token string `protobuf:"bytes,8,opt,name=token,proto3" json:"token,omitempty"`
	// CloudMetadata describes the instance from the cloud environment.
	// Optional, only set when running on a supported cloud
	CloudMetadata *CloudMetadata `protobuf:"bytes,9,opt,name=cloud_metadata,json=cloudMetadata,proto3" json:"cloud_metadata,omitempty"`
	// KeyValues specifies additional runtime configuration parameters
	// as key=value pairs
	KeyValues map[string]string `protobuf:"bytes,10,rep,name=key_values,json=keyValues,proto3" json:"key_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// SELinux indicates that the node has SELinux support on
	SELinux              bool     `protobuf:"varint,11,opt,name=selinux,proto3" json:"selinux,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RuntimeConfig) Reset()      { *m = RuntimeConfig{} }
func (*RuntimeConfig) ProtoMessage() {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{2}
}
func (m *RuntimeConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RuntimeConfig.Unmarshal(m, b)
}
func (m *RuntimeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RuntimeConfig.Marshal(b, m, deterministic)
}
func (m *RuntimeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeConfig.Merge(m, src)
}
func (m *RuntimeConfig) XXX_Size() int {
	return xxx_messageInfo_RuntimeConfig.Size(m)
}
func (m *RuntimeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeConfig proto.InternalMessageInfo

func (m *RuntimeConfig) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *RuntimeConfig) GetAdvertiseAddr() string {
	if m != nil {
		return m.AdvertiseAddr
	}
	return ""
}

func (m *RuntimeConfig) GetDockerDevice() string {
	if m != nil {
		return m.DockerDevice
	}
	return ""
}

func (m *RuntimeConfig) GetSystemDevice() string {
	if m != nil {
		return m.SystemDevice
	}
	return ""
}

func (m *RuntimeConfig) GetMounts() []*Mount {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *RuntimeConfig) GetStateDir() string {
	if m != nil {
		return m.StateDir
	}
	return ""
}

func (m *RuntimeConfig) GetTempDir() string {
	if m != nil {
		return m.TempDir
	}
	return ""
}

func (m *RuntimeConfig) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RuntimeConfig) GetCloudMetadata() *CloudMetadata {
	if m != nil {
		return m.CloudMetadata
	}
	return nil
}

func (m *RuntimeConfig) GetKeyValues() map[string]string {
	if m != nil {
		return m.KeyValues
	}
	return nil
}

func (m *RuntimeConfig) GetSELinux() bool {
	if m != nil {
		return m.SELinux
	}
	return false
}

// Device is a system I/O device
type Device struct {
	// Name identifies the device
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{3}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Device.Unmarshal(m, b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Device.Marshal(b, m, deterministic)
}
func (m *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(m, src)
}
func (m *Device) XXX_Size() int {
	return xxx_messageInfo_Device.Size(m)
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *Device) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Mount is mount point
type Mount struct {
	// Name identifies the mount point
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Source specifies the source directory
	Source               string   `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Mount) Reset()      { *m = Mount{} }
func (*Mount) ProtoMessage() {}
func (*Mount) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{4}
}
func (m *Mount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Mount.Unmarshal(m, b)
}
func (m *Mount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Mount.Marshal(b, m, deterministic)
}
func (m *Mount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mount.Merge(m, src)
}
func (m *Mount) XXX_Size() int {
	return xxx_messageInfo_Mount.Size(m)
}
func (m *Mount) XXX_DiscardUnknown() {
	xxx_messageInfo_Mount.DiscardUnknown(m)
}

var xxx_messageInfo_Mount proto.InternalMessageInfo

func (m *Mount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Mount) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

// CloudMetadata describes the instance in the cloud
type CloudMetadata struct {
	// NodeName specifies the optional node name override.
	// Can be specified either on command line or derived from cloud environment.
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// InstanceType specifies the type of the instance running
	InstanceType string `protobuf:"bytes,2,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// InstanceID provides the cloud-specific instance ID
	InstanceId           string   `protobuf:"bytes,3,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloudMetadata) Reset()      { *m = CloudMetadata{} }
func (*CloudMetadata) ProtoMessage() {}
func (*CloudMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{5}
}
func (m *CloudMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloudMetadata.Unmarshal(m, b)
}
func (m *CloudMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloudMetadata.Marshal(b, m, deterministic)
}
func (m *CloudMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudMetadata.Merge(m, src)
}
func (m *CloudMetadata) XXX_Size() int {
	return xxx_messageInfo_CloudMetadata.Size(m)
}
func (m *CloudMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CloudMetadata proto.InternalMessageInfo

func (m *CloudMetadata) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *CloudMetadata) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *CloudMetadata) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func init() {
	proto.RegisterType((*Version)(nil), "proto.Version")
	proto.RegisterType((*SystemInfo)(nil), "proto.SystemInfo")
	proto.RegisterType((*RuntimeConfig)(nil), "proto.RuntimeConfig")
	proto.RegisterMapType((map[string]string)(nil), "proto.RuntimeConfig.KeyValuesEntry")
	proto.RegisterType((*Device)(nil), "proto.Device")
	proto.RegisterType((*Mount)(nil), "proto.Mount")
	proto.RegisterType((*CloudMetadata)(nil), "proto.CloudMetadata")
}

func init() { proto.RegisterFile("discovery.proto", fileDescriptor_1e7ff60feb39c8d0) }

var fileDescriptor_1e7ff60feb39c8d0 = []byte{
	// 596 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0xa6, 0xeb, 0xff, 0x69, 0x53, 0x86, 0x35, 0x4d, 0xa1, 0x43, 0x6a, 0xd5, 0x32, 0xd4, 0xab,
	0x4e, 0x1a, 0x5c, 0xc0, 0xe0, 0x02, 0xb6, 0x4e, 0xd5, 0x04, 0xe3, 0x22, 0x9b, 0x76, 0x1b, 0x65,
	0xf1, 0x59, 0x15, 0x35, 0xb1, 0x23, 0xc7, 0xa9, 0x96, 0x07, 0xe0, 0x1d, 0xb8, 0xe4, 0xc9, 0xb8,
	0xe0, 0x19, 0x78, 0x00, 0x64, 0xc7, 0x9e, 0x5a, 0x58, 0xb9, 0x8a, 0xbf, 0x1f, 0x7f, 0x76, 0xce,
	0xf1, 0x81, 0xa7, 0x34, 0xca, 0x42, 0xbe, 0x42, 0x51, 0x4c, 0x53, 0xc1, 0x25, 0x27, 0x75, 0xfd,
	0xe9, 0x1f, 0x2c, 0x38, 0x5f, 0xc4, 0x78, 0xa4, 0xd1, 0x6d, 0x7e, 0x77, 0x84, 0x49, 0x2a, 0x8d,
	0xa7, 0x3f, 0xf8, 0x5b, 0x94, 0x51, 0x82, 0x99, 0x0c, 0x92, 0xd4, 0x18, 0x60, 0xc1, 0x17, 0xbc,
	0x5c, 0x8f, 0xc6, 0xd0, 0xbc, 0x41, 0x91, 0x45, 0x9c, 0x11, 0x17, 0x9a, 0x69, 0x50, 0xc4, 0x3c,
	0xa0, 0x6e, 0x65, 0x58, 0x99, 0x74, 0x3d, 0x0b, 0x47, 0xaf, 0x00, 0xae, 0x8a, 0x4c, 0x62, 0x72,
	0xc1, 0xee, 0xf8, 0x7f, 0x7c, 0xbf, 0xab, 0xe0, 0x78, 0x39, 0x53, 0xe7, 0x9d, 0x71, 0x76, 0x17,
	0x2d, 0x08, 0x81, 0x9a, 0xe0, 0x31, 0x6a, 0x63, 0xdb, 0xd3, 0x6b, 0x72, 0x08, 0xbd, 0x80, 0xae,
	0x50, 0xc8, 0x28, 0x43, 0x3f, 0xa0, 0x54, 0xb8, 0x3b, 0x5a, 0x75, 0x1e, 0xd8, 0x4f, 0x94, 0x0a,
	0x32, 0x06, 0x87, 0xf2, 0x70, 0x89, 0xc2, 0xa7, 0xb8, 0x8a, 0x42, 0x74, 0xab, 0xda, 0xd5, 0x2d,
	0xc9, 0x99, 0xe6, 0x94, 0x29, 0xd3, 0x37, 0xb3, 0xa6, 0x5a, 0x69, 0x2a, 0x49, 0x63, 0x7a, 0x09,
	0x8d, 0x84, 0xe7, 0x4c, 0x66, 0x6e, 0x7d, 0x58, 0x9d, 0x74, 0x8e, 0xbb, 0xe5, 0xbf, 0x4f, 0x2f,
	0x15, 0xe9, 0x19, 0x8d, 0x1c, 0x40, 0x3b, 0x93, 0x81, 0x44, 0x9f, 0x46, 0xc2, 0x6d, 0xe8, 0x98,
	0x96, 0x26, 0x66, 0x91, 0x20, 0xcf, 0xa1, 0x25, 0x31, 0x49, 0xb5, 0xd6, 0xd4, 0x5a, 0x53, 0x61,
	0x25, 0xed, 0x41, 0x5d, 0xf2, 0x25, 0x32, 0xb7, 0xa5, 0xf9, 0x12, 0x90, 0xf7, 0xd0, 0x0b, 0x63,
	0x9e, 0x53, 0x3f, 0x41, 0x19, 0xd0, 0x40, 0x06, 0x6e, 0x7b, 0x58, 0x99, 0x74, 0x8e, 0xf7, 0xcc,
	0xd9, 0x67, 0x4a, 0xbc, 0x34, 0x9a, 0xe7, 0x84, 0xeb, 0x90, 0x9c, 0x02, 0x2c, 0xb1, 0xf0, 0x57,
	0x41, 0x9c, 0x63, 0xe6, 0x82, 0xbe, 0xf4, 0xd8, 0x6c, 0xdc, 0xa8, 0xef, 0xf4, 0x33, 0x16, 0x37,
	0xda, 0x75, 0xce, 0xa4, 0x28, 0xbc, 0xf6, 0xd2, 0x62, 0x72, 0x08, 0xcd, 0x0c, 0xe3, 0x88, 0xe5,
	0xf7, 0x6e, 0x67, 0x58, 0x99, 0xb4, 0x4e, 0x3b, 0xbf, 0x7e, 0x0e, 0x9a, 0x57, 0xe7, 0x5f, 0x14,
	0xe5, 0x59, 0xad, 0xff, 0x01, 0x7a, 0x9b, 0x19, 0x64, 0x17, 0xaa, 0x4b, 0x2c, 0x4c, 0xc7, 0xd4,
	0x52, 0xfd, 0xa1, 0xbe, 0x8a, 0xe9, 0x53, 0x09, 0x4e, 0x76, 0xde, 0x56, 0x4e, 0x6a, 0xdf, 0x7f,
	0x0c, 0x9e, 0x8c, 0x5e, 0x40, 0xc3, 0x54, 0x9a, 0x40, 0x8d, 0x05, 0xc9, 0x43, 0xbb, 0xd5, 0x7a,
	0xf4, 0x0e, 0xea, 0xba, 0xd0, 0x8f, 0x89, 0x64, 0x1f, 0x1a, 0x19, 0xcf, 0x45, 0x68, 0xb3, 0x0d,
	0x32, 0xc1, 0xf7, 0xe0, 0x6c, 0xd4, 0x49, 0xf5, 0x88, 0x71, 0x8a, 0xfe, 0x5a, 0x4e, 0x4b, 0x11,
	0x5f, 0x55, 0xd6, 0x18, 0x9c, 0x88, 0x65, 0x32, 0x60, 0x21, 0xfa, 0xb2, 0x48, 0x6d, 0x64, 0xd7,
	0x92, 0xd7, 0x45, 0x8a, 0x64, 0x00, 0x9d, 0x07, 0x53, 0x44, 0xcd, 0x9b, 0x02, 0x4b, 0x5d, 0xd0,
	0xf2, 0xe4, 0xe3, 0x6f, 0x3b, 0xd0, 0x9e, 0xd9, 0xd9, 0x23, 0x1f, 0x61, 0x77, 0x8e, 0x72, 0xf3,
	0x65, 0xef, 0x4f, 0xcb, 0x31, 0x9b, 0xda, 0x31, 0x9b, 0x9e, 0xab, 0x19, 0xec, 0xef, 0x3d, 0xd6,
	0x27, 0x72, 0x02, 0xce, 0x1c, 0xe5, 0xda, 0x10, 0x6d, 0xdb, 0xfe, 0xcc, 0x6c, 0x5f, 0xb3, 0xce,
	0xa0, 0x37, 0x47, 0x79, 0x96, 0x0b, 0x81, 0x4c, 0x5e, 0x47, 0xaa, 0x6a, 0x5b, 0x36, 0xf7, 0xff,
	0xe1, 0xaf, 0xed, 0xe8, 0x93, 0x37, 0x00, 0x73, 0x94, 0x76, 0xd6, 0xb7, 0x25, 0xf4, 0xcc, 0xf1,
	0xc6, 0x77, 0xdb, 0xd0, 0xf0, 0xf5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x8c, 0x6f, 0x40,
	0x89, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DiscoveryClient is the client API for Discovery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DiscoveryClient interface {
	// GetRuntimeConfig returns the agent's runtime configuration
	GetRuntimeConfig(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*RuntimeConfig, error)
	// GetSystemInfo queries system information on the host the agent is running on
	GetSystemInfo(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SystemInfo, error)
	// GetCurrentTime returns the node's current time as UTC timestamp
	GetCurrentTime(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Timestamp, error)
	// GetVersion returns the agent's version information.
	GetVersion(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*Version, error)
}

type discoveryClient struct {
	cc *grpc.ClientConn
}

func NewDiscoveryClient(cc *grpc.ClientConn) DiscoveryClient {
	return &discoveryClient{cc}
}

func (c *discoveryClient) GetRuntimeConfig(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*RuntimeConfig, error) {
	out := new(RuntimeConfig)
	err := c.cc.Invoke(ctx, "/proto.Discovery/GetRuntimeConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discoveryClient) GetSystemInfo(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SystemInfo, error) {
	out := new(SystemInfo)
	err := c.cc.Invoke(ctx, "/proto.Discovery/GetSystemInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discoveryClient) GetCurrentTime(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Timestamp, error) {
	out := new(types.Timestamp)
	err := c.cc.Invoke(ctx, "/proto.Discovery/GetCurrentTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discoveryClient) GetVersion(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/proto.Discovery/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiscoveryServer is the server API for Discovery service.
type DiscoveryServer interface {
	// GetRuntimeConfig returns the agent's runtime configuration
	GetRuntimeConfig(context.Context, *types.Empty) (*RuntimeConfig, error)
	// GetSystemInfo queries system information on the host the agent is running on
	GetSystemInfo(context.Context, *types.Empty) (*SystemInfo, error)
	// GetCurrentTime returns the node's current time as UTC timestamp
	GetCurrentTime(context.Context, *types.Empty) (*types.Timestamp, error)
	// GetVersion returns the agent's version information.
	GetVersion(context.Context, *types.Empty) (*Version, error)
}

// UnimplementedDiscoveryServer can be embedded to have forward compatible implementations.
type UnimplementedDiscoveryServer struct {
}

func (*UnimplementedDiscoveryServer) GetRuntimeConfig(ctx context.Context, req *types.Empty) (*RuntimeConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRuntimeConfig not implemented")
}
func (*UnimplementedDiscoveryServer) GetSystemInfo(ctx context.Context, req *types.Empty) (*SystemInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (*UnimplementedDiscoveryServer) GetCurrentTime(ctx context.Context, req *types.Empty) (*types.Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentTime not implemented")
}
func (*UnimplementedDiscoveryServer) GetVersion(ctx context.Context, req *types.Empty) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}

func RegisterDiscoveryServer(s *grpc.Server, srv DiscoveryServer) {
	s.RegisterService(&_Discovery_serviceDesc, srv)
}

func _Discovery_GetRuntimeConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServer).GetRuntimeConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Discovery/GetRuntimeConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServer).GetRuntimeConfig(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discovery_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Discovery/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServer).GetSystemInfo(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discovery_GetCurrentTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServer).GetCurrentTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Discovery/GetCurrentTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServer).GetCurrentTime(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discovery_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Discovery/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServer).GetVersion(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Discovery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Discovery",
	HandlerType: (*DiscoveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRuntimeConfig",
			Handler:    _Discovery_GetRuntimeConfig_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _Discovery_GetSystemInfo_Handler,
		},
		{
			MethodName: "GetCurrentTime",
			Handler:    _Discovery_GetCurrentTime_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _Discovery_GetVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "discovery.proto",
}
